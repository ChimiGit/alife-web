---
---

<div class="relative min-h-screen overflow-hidden bg-[#FBEC61]" style="font-family: 'Inter', sans-serif; margin-top: -5rem">
  <!-- Particle Animation Canvas -->
  <canvas id="particleCanvas" class="fixed inset-0 z-5" style="touch-action: none; background-color: transparent; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;"></canvas>

 <!-- Text Content -->
  <section class="absolute bottom-50 left-0 right-0 mb-8 sm:mb-10 px-4 sm:px-6 z-10">
    <div class="max-w-6xl mx-auto px-4 sm:px-6">
        <h1
          class="text-4xl sm:text-6xl md:text-8xl lg:text-[128px] text-primary"
          style={`font-family: ${
            "'GT Alpina Fine', serif"
          }; margin: 0; line-height: 0.8;`}
        >
          Where
        </h1>
        <h1
        class="text-4xl sm:text-6xl md:text-8xl lg:text-[128px] text-primary"
        style={`font-family: ${
          "'GT Alpina Fine', serif"
        }; margin: 0; line-height: 0.8;`}
          >
        Evolution Meets
        </h1>
      <h1
      class="text-4xl sm:text-6xl md:text-8xl lg:text-[128px] text-primary"
      style={`font-family: ${
        "'GT Alpina Fine', serif"
      }; margin: 0; line-height: 0.8;`}
    >
        Innovation
      </h1>
      <p
        class="text-primary max-w-md sm:max-w-xl md:max-w-3xl lg:max-w-4xl font-light mt-6 sm:mt-8 lg:mt-10 text-sm sm:text-base md:text-lg"
        style={`font-family: ${
          "'Inter', sans-serif"
        }; font-size: 16px; line-height: 150%;`}
      >
        We're cultivating alternative approaches through evolution itselfâ€”creating systems that don't just optimize, but discover, surprise, and continuously evolve. This is where we pave a way for a future not engineered, but grown organically through bottom-up ecosystems where humans and artificial life forms collaborate as complementary partners.
      </p>
   </div>
  </section>
</div>

<script>
// import { formatDiagnosticsWithColorAndContext } from "typescript";

  document.addEventListener('DOMContentLoaded', () => {
    // Set up the canvas and other variables
    const canvas = document.getElementById('particleCanvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) return; // Exit if canvas context is not available
    
    let lines: any[] = [];
    const particleRadius = 1.7;
    const baseLineSpeed = 1.5;
    const baseLineSpread = 230;
    const baseDensity = 2500;
    const lineSeparation = 240;
    const fadeInDistance = 150;

    function resizeCanvas() {
        if (!ctx) return;
        
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;

        lines = [];

        // Pre-populate lines across the screen (simulate ongoing animation)
        const centerX = window.innerWidth / 2 + 40;
        const numInitialLines = Math.ceil(window.innerWidth / lineSeparation) + 2;

        for (let i = -2; i < numInitialLines; i++) {
          const line = createLine(1);
          line.xOffset = centerX + i * lineSeparation; // position as if already moved
          // line.opacity = 1; // skip fade-in for preloaded lines
          lines.push(line);
        }

        animate();
    }

    class Particle {
      relativeX: number;

      y: number;

      speedY: number;

      constructor(relativeX: number, y: number, speedY: number) {
        this.relativeX = relativeX;
        this.y = y;
        this.speedY = speedY;
      }

      // Update particle's position with gentle vertical movement
      update() {
        this.y += this.speedY;
        if (this.y < 0 || this.y > canvas.height) {
          this.speedY *= -1;
        }
      }
    }
    
    // Helper function to create a single line of particles with a random speed
    function createLine(direction: number = 1) {
      const particles: Particle[] = [];
      for (let j = 0; j < baseDensity; j++) {
        const randomX = Math.pow(Math.random(), 0.5);
        const y = Math.random() * window.innerHeight;
        const speedY = (Math.random() - 0.5) * 1.0;
        particles.push(new Particle(randomX, y, speedY));
      }

      return {
      xOffset: window.innerWidth / 2 + 40, // Start from center shifted more right
      speed: baseLineSpeed * direction, // Direction: 1 for right, -1 for left
      particles,
      // track fade-in state and reference start position
      opacity: 0,
      startX: window.innerWidth / 2 + 40,
      };
    }

    // Main animation loop
    function animate() {
      if (!ctx) return;
      
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      // Add new line when the last line has moved a specific distance
      // if (lines.length === 0 || Math.floor(Math.abs(lines[lines.length - 1].xOffset - (window.innerWidth / 2 + 40))) % lineSeparation === 0) {
      //   lines.push(createLine(1)); // Moving right only
      // }
      const centerX = window.innerWidth / 2 + 40;
      if (lines.length === 0 || Math.abs(lines[lines.length - 1].xOffset - centerX) >= lineSeparation) {
        lines.push(createLine(1)); // Moving right only
}

      // Update and draw each line
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i];
        line.xOffset += line.speed;

        // Calculate current spread and density based on distance from shifted center
        const distanceFromCenter = Math.abs(line.xOffset - centerX);
        const maxDistance = window.innerWidth / 2;
        const progress = distanceFromCenter / maxDistance;
        // const currentLineSpread = baseLineSpread * (1 - progress);
        const currentLineSpread= baseLineSpread;
        
  // Make right side denser by adjusting density calculation
  const isRightSide = line.xOffset > centerX;
        const densityMultiplier = isRightSide ? 3.5 : 0; // more denser on right, less dense on left
        const currentDensity = baseDensity * (1 - progress) * densityMultiplier;
        
        

        const particlesToDraw = Math.floor(currentDensity);
        
        // update fade-in opacity based on how far the line has traveled from its start
        const traveled = Math.abs(line.xOffset - (line.startX ?? (window.innerWidth / 2 + 40)));
        line.opacity = Math.min(1, traveled / fadeInDistance);

        line.particles.slice(0, particlesToDraw).forEach((p: Particle) => {
          p.update();

          const xOffset = (p.relativeX * currentLineSpread) - (currentLineSpread / 2);
          // baseAlpha varies across the spread (0..1), keep a small minimum so particles remain visible
          const baseAlpha = Math.max(0.2, (xOffset + (currentLineSpread / 2)) / currentLineSpread);
          const finalAlpha = baseAlpha * (line.opacity ?? 1);

          ctx.beginPath();
          ctx.arc(xOffset + line.xOffset, p.y, particleRadius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(28, 165, 0, ${finalAlpha})`;
          ctx.fill();
        });

        // Remove lines that have moved off-screen to the right
        if (line.xOffset > window.innerWidth + baseLineSpread) {
          lines.splice(i, 1);
        }
      }

      requestAnimationFrame(animate);
    }

    // Listen for window resize to make the canvas responsive
    window.addEventListener('resize', resizeCanvas);

    // Initial setup
    resizeCanvas();
  });
</script>
