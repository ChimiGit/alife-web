<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moving Pattern</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

      <!-- Text Content -->
    <main class="absolute top-0 left-0 w-full h-full z-10 flex items-center">
        <div class="text-left max-w-7xl pl-8 sm:pl-12 lg:pl-40">
        <h1 class="text-4xl sm:text-6xl md:text-7xl lg:text-8xl xl:text-9xl text-primary" style="font-family: 'GT Alpina Fine', serif; line-height: 0.8; margin: 0;">
            Where
        </h1>
        <h1 class="text-4xl sm:text-6xl md:text-7xl lg:text-8xl xl:text-9xl text-primary" style="font-family: 'GT Alpina Fine', serif; line-height: 0.8; margin: 0;">
            Evolution Meets
        </h1>
        <h1 class="text-4xl sm:text-6xl md:text-7xl lg:text-8xl xl:text-9xl text-primary" style="font-family: 'GT Alpina Fine', serif; line-height: 0.8; margin: 0;">
            Innovation
        </h1>
        <p class="text-primary max-w-4xl text-sm sm:text-base md:text-lg font-light mt-10" style="font-family: 'Inter', sans-serif;">
            We're cultivating alternative approaches through evolution itselfâ€”creating systems <br/>
            that don't just optimize, but discover, surprise, and continuously evolve. This is <br/>
            where we pave a way for a future not engineered, but grown organically through <br/>
            bottom-up ecosystems where humans and artificial life forms collaborate as <br/>
            complementary partners.
        </p>
        </div>
    </main>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let particles = [];
            const PARTICLE_RADIUS = 2; // Increased particle radius

            let ripples = [];
            let rippleInterval = 1000;
            let lastRippleTime = Date.now();
            const rippleEffectZone = 30;

            const ringRadii = [
                { min: 120, max: 250, count: 1500 },
                { min: 300, max: 450, count: 2000 },
                { min: 500, max: 650, count: 2500 }
            ];

            function generateAllParticles() {
                particles = [];
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight;

                ringRadii.forEach(ring => {
                    for (let i = 0; i < ring.count; i++) {
                        const radius = ring.min + Math.random() * (ring.max - ring.min);
                        const angle = Math.PI * (Math.random() - 0.5) + Math.PI / 2;
                        
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY - radius * Math.sin(angle);
                        
                        particles.push({
                            x,
                            y,
                            vx: (Math.random() - 0.5) * 0.2,
                            vy: (Math.random() - 0.5) * 0.2,
                            initialX: x,
                            initialY: y,
                            radius,
                            alpha: 0
                        });
                    }
                });
            }

            function draw() {
                ctx.fillStyle = '#29D6E2'; 
                ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

                particles.forEach(p => {
                    // Draw with a purple color with dynamic opacity
                    if (p.alpha > 0) {
                        ctx.fillStyle = `white`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            function update() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight;
                const now = Date.now();

                // Generate new ripple if interval has passed
                if (now - lastRippleTime > rippleInterval) {
                    ripples.push({
                        radius: 0,
                        speed: 3,
                        force: 5.0 // Increased force for more dramatic movement
                    });
                    lastRippleTime = now;
                }

                // Update and filter ripples
                ripples = ripples.filter(r => {
                    r.radius += r.speed;
                    return r.radius < Math.max(canvas.width, canvas.height);
                });

                particles.forEach(p => {
                    // Update position with current velocities
                    p.x += p.vx;
                    p.y += p.vy;

                    let maxAlpha = 0;
                    ripples.forEach(r => {
                        const dx = p.x - centerX;
                        const dy = p.y - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // If the particle is within the ripple's effect zone
                        if (Math.abs(distance - r.radius) < rippleEffectZone) {
                            const angle = Math.atan2(dy, dx);
                            p.vx += Math.cos(angle) * r.force;
                            p.vy += Math.sin(angle) * r.force;

                            // Calculate alpha based on distance from the ripple's center
                            const currentAlpha = 1 - (Math.abs(distance - r.radius) / rippleEffectZone);
                            if (currentAlpha > maxAlpha) {
                                maxAlpha = currentAlpha;
                            }
                        }
                    });
                    
                    if (maxAlpha > 0) {
                        p.alpha = maxAlpha;
                    } else {
                        p.alpha -= 0.1;
                    }
                    if (p.alpha < 0) {
                        p.alpha = 0;
                    }

                    // Dampen the velocity to bring particles back to their original position
                    const returnForce = 0.05;
                    const dxToInitial = p.initialX - p.x;
                    const dyToInitial = p.initialY - p.y;

                    p.vx += dxToInitial * returnForce;
                    p.vy += dyToInitial * returnForce;

                    p.vx *= 0.90; // Reduced dampening for more sustained movement
                    p.vy *= 0.90;
                });
            }
            
            function animate() {
                update();
                draw();
                requestAnimationFrame(animate);
            }

            function resizeCanvas() {
                // Get device pixel ratio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas size
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                
                // Scale context to match device pixel ratio
                ctx.scale(dpr, dpr);
                
                // Set CSS size
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight}px`;
                
                generateAllParticles();
                draw();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            animate();
        };
    </script>
</body>
</html>
