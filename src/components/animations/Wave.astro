---
// Astro component - no props needed for this standalone component
---

<div class="relative w-full h-screen">
  <canvas id="halftone-canvas" class="w-full h-screen" style="pointer-events: none;"></canvas>
</div>


<script>
  let particleSize = 10;
  let particleColor = "#ffffff";
  let animationSpeed = 0.05;
  let particleDensity = 12;
  let sharpness = 1.0; // 0..1
  let useAdditive = true;

  const canvas = document.getElementById('halftone-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');
  
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  let animationFrameId: number | undefined;
  let time = 0;

  const particles: Array<{
    baseX: number;
    baseY: number;
    offsetX: number;
    offsetY: number;
    randomPhase: number;
  }> = [];

  const initializeParticles = () => {
    particles.length = 0;
    const gridSize = particleDensity;
    const rows = Math.ceil(canvas.height / gridSize);
    const cols = Math.ceil(canvas.width / gridSize);

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        particles.push({
          baseX: x * gridSize,
          baseY: y * gridSize,
          offsetX: (Math.random() - 0.5) * 10,
          offsetY: (Math.random() - 0.5) * 10,
          randomPhase: Math.random() * Math.PI * 2,
        });
      }
    }
  };

  const resizeCanvas = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeParticles();
  };

  const hexToRgb = (hex: string) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        }
      : { r: 255, g: 255, b: 255 };
  };

  const drawParticleWave = () => {
    const rgb = hexToRgb(particleColor);
    // Shift wave center 50% downward relative to canvas height
    const centerXRef = canvas.width / 2;
    const centerYOffsetPercent = 0.5; // 50% downward
    const centerYRef = canvas.height / 2 + canvas.height * centerYOffsetPercent;

    // Compute max distance from shifted center to any canvas corner for normalization
    const maxDistance = Math.max(
      Math.hypot(centerXRef - 0, centerYRef - 0),
      Math.hypot(centerXRef - canvas.width, centerYRef - 0),
      Math.hypot(centerXRef - 0, centerYRef - canvas.height),
      Math.hypot(centerXRef - canvas.width, centerYRef - canvas.height)
    );

    // Set blending mode for clearer/brighter overlaps
    ctx!.globalCompositeOperation = useAdditive ? 'lighter' : 'source-over';

    particles.forEach((particle) => {
      const centerX = particle.baseX + particle.offsetX + Math.sin(time + particle.randomPhase) * 3;
      const centerY = particle.baseY + particle.offsetY + Math.cos(time * 0.7 + particle.randomPhase) * 2;

      const distanceFromCenter = Math.hypot(centerX - centerXRef, centerY - centerYRef);
      const normalizedDistance = distanceFromCenter / maxDistance;

      const waveOffset = Math.sin(normalizedDistance * 22.5 - time) * 0.5 + 0.5;
      const size = particleSize * waveOffset * 0.8;

      // Solid core for crispness
      const coreRadius = (size / 2) * (0.3 + 0.55 * sharpness); // 30%..85% of radius
      const baseAlpha = Math.min(1, waveOffset * (0.55 + 0.45 * sharpness));
      if (coreRadius > 0) {
        ctx!.beginPath();
        ctx!.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
        ctx!.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${baseAlpha})`;
        ctx!.fill();
      }

      // Tight halo for contrast
      const outerRadius = size / 2;
      if (outerRadius > coreRadius) {
        const gradient = ctx!.createRadialGradient(centerX, centerY, coreRadius, centerX, centerY, outerRadius);
        gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${baseAlpha})`);
        gradient.addColorStop(0.85, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${baseAlpha * 0.35})`);
        gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);

        ctx!.beginPath();
        ctx!.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
        ctx!.fillStyle = gradient;
        ctx!.fill();
      }
    });
  };

  const animate = () => {
    ctx!.clearRect(0, 0, canvas.width, canvas.height);
    drawParticleWave();
    time += animationSpeed;
    animationFrameId = requestAnimationFrame(animate);
  };


  if (canvas && ctx) {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    animate();
  }
</script>
