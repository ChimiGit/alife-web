---
// Circular ring pattern particle system component
import Header from './Header.astro';

export interface Props {
  lang?: string;
  translations?: any;
}

const { lang = 'en', translations } = Astro.props;
---

<div class="relative min-h-screen overflow-hidden" style="background-color: #29D6E2;">
	<canvas id="canvas" class="absolute inset-0 block"></canvas>
    
	<div class="relative z-10">
		<Header lang={lang} translations={translations} />
	</div>
	
	<main class="relative z-20 min-h-screen mt-5">
		<div class="text-left max-w-7xl mx-auto px-4 space-y-6">
		<h1 class="text-9xl text-primary" style="font-family: 'GT Alpina Fine', serif;">
			{translations?.titleLine1 || 'Where'}
		</h1>
		<h1 class="text-9xl text-primary" style="font-family: 'GT Alpina Fine', serif;">
			{translations?.titleLine2 || 'Evolution Meets'}
		</h1>
		<h1 class="text-9xl text-primary" style="font-family: 'GT Alpina Fine', serif;">
			{translations?.titleLine3 || 'Innovation'}
		</h1>
		<p class="text-primary max-w-4xl leading-relaxed" style="font-family: 'Inter', sans-serif; font-size: '16px';">
			{translations?.description || "We're cultivating alternative approaches through evolution itselfâ€”creating systems that don't just optimize, but discover, surprise, and continuously evolve. This is where we pave a way for a future not engineered, but grown organically through bottom-up ecosystems where humans and artificial life forms collaborate as complementary partners."}
		</p>
		</div>
	</main>
	
	<!-- TypeScript Particle System -->
	<script>
		// Particle system with ripple effects
		const canvas = document.getElementById('canvas') as HTMLCanvasElement;
		if (!canvas) throw new Error('Canvas not found');
		
		const ctx = canvas.getContext('2d')!;
		
		// Set canvas size
		function resizeCanvas() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		}
		resizeCanvas();
		window.addEventListener('resize', resizeCanvas);
		
		// Particle class
		class Particle {
			x: number;
			y: number;
			baseX: number;
			baseY: number;
			size: number;
			opacity: number;
			
			constructor(x: number, y: number, size: number = 2) {
				this.x = x;
				this.y = y;
				this.baseX = x;
				this.baseY = y;
				this.size = size;
				this.opacity = 0.8;
			}
			
			draw() {
				ctx.save();
				ctx.globalAlpha = this.opacity;
				ctx.fillStyle = 'white';
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			}
			
			update(mouseX: number, mouseY: number, ripples: Ripple[]) {
				// Mouse attraction
				const dx = mouseX - this.x;
				const dy = mouseY - this.y;
				const distance = Math.sqrt(dx * dx + dy * dy);
				const maxDistance = 100;
				
				if (distance < maxDistance) {
					const force = (maxDistance - distance) / maxDistance;
					this.x += dx * force * 0.02;
					this.y += dy * force * 0.02;
				}
				
				// Ripple effects
				ripples.forEach(ripple => {
					const rippleDx = this.x - ripple.x;
					const rippleDy = this.y - ripple.y;
					const rippleDistance = Math.sqrt(rippleDx * rippleDx + rippleDy * rippleDy);
					
					if (Math.abs(rippleDistance - ripple.radius) < ripple.width && ripple.opacity > 0) {
						const pushForce = ripple.opacity * 20;
						const angle = Math.atan2(rippleDy, rippleDx);
						this.x += Math.cos(angle) * pushForce;
						this.y += Math.sin(angle) * pushForce;
					}
				});
				
				// Return to base position
				this.x += (this.baseX - this.x) * 0.05;
				this.y += (this.baseY - this.y) * 0.05;
			}
		}
		
		// Ripple class
		class Ripple {
			x: number;
			y: number;
			radius: number;
			maxRadius: number;
			opacity: number;
			width: number;
			
			constructor(x: number, y: number, maxRadius: number = 300) {
				this.x = x;
				this.y = y;
				this.radius = 0;
				this.maxRadius = maxRadius;
				this.opacity = 1;
				this.width = 20;
			}
			
			update() {
				this.radius += 3;
				this.opacity = Math.max(0, 1 - (this.radius / this.maxRadius));
				return this.opacity > 0;
			}
			
			draw() {
				if (this.opacity <= 0) return;
				
				ctx.save();
				ctx.globalAlpha = this.opacity * 0.3;
				ctx.strokeStyle = 'white';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
				ctx.stroke();
				ctx.restore();
			}
		}
		
		// Initialize particles in concentric rings
		const particles: Particle[] = [];
		const ripples: Ripple[] = [];
		
		function createParticleRings() {
			particles.length = 0;
			const newCenterX = canvas.width / 2;
			const newCenterY = canvas.height / 2;
			
			// Calculate how many rings needed to fill entire screen
			const maxDistanceFromCenter = Math.sqrt(
				Math.pow(Math.max(newCenterX, canvas.width - newCenterX), 2) +
				Math.pow(Math.max(newCenterY, canvas.height - newCenterY), 2)
			);
			
			const ringSpacing = 25; // Closer spacing for better coverage
			const numRings = Math.ceil(maxDistanceFromCenter / ringSpacing);
			
			// Create concentric rings of particles to fill entire screen
			for (let ring = 1; ring <= numRings; ring++) {
				const radius = ring * ringSpacing;
				const particlesInRing = Math.max(8, Math.floor(ring * 6)); // More particles in outer rings
				
				for (let i = 0; i < particlesInRing; i++) {
					const angle = (i / particlesInRing) * Math.PI * 2;
					const x = newCenterX + Math.cos(angle) * radius;
					const y = newCenterY + Math.sin(angle) * radius;
					
					// Only add particles that are within screen bounds (with some padding)
					if (x >= -50 && x <= canvas.width + 50 && y >= -50 && y <= canvas.height + 50) {
						particles.push(new Particle(x, y, 1.5));
					}
				}
			}
		}
		
		createParticleRings();
		
		// Mouse tracking
		let mouseX = canvas.width / 2;
		let mouseY = canvas.height / 2;
		
		canvas.addEventListener('mousemove', (e) => {
			mouseX = e.clientX;
			mouseY = e.clientY;
		});
		
		// Click to create ripples
		canvas.addEventListener('click', (e) => {
			ripples.push(new Ripple(e.clientX, e.clientY));
		});
		
		// Touch support for mobile
		canvas.addEventListener('touchstart', (e) => {
			e.preventDefault();
			const touch = e.touches[0];
			ripples.push(new Ripple(touch.clientX, touch.clientY));
		});
		
		// Auto-generate ripples from center
		setInterval(() => {
			ripples.push(new Ripple(canvas.width / 2, canvas.height / 2, 400));
		}, 2000);
		
		// Animation loop
		function animate() {
			// Clear with turquoise background
			ctx.fillStyle = "#29D6E2";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			// Update and draw particles
			particles.forEach(particle => {
				particle.update(mouseX, mouseY, ripples);
				particle.draw();
			});
			
			// Update and draw ripples
			for (let i = ripples.length - 1; i >= 0; i--) {
				const ripple = ripples[i];
				if (!ripple.update()) {
					ripples.splice(i, 1);
				} else {
					ripple.draw();
				}
			}
			
			requestAnimationFrame(animate);
		}
		
		// Handle window resize
		window.addEventListener('resize', () => {
			resizeCanvas();
			createParticleRings();
		});
		
		// Start animation
		animate();
	</script>
</div>